//spatial indexing using hexagonal grid, bottom up
//root is layer 0, z = 0
//layer 1 is tranformed by 1/3 along the major axis and the hexagons are rotated 90 degrees
//Each layer is a hexagonal grid of hexagons
//Each node is a hexagon
//Each node has one or more parent nodes
//Each node above layer 0 has seven child nodes
//Of the seven child nodes, one is unique to the parent node
//The unique child node's coordinate is the parent node's coordinate multiplied by 3 along the major axis
//Each node has a coordinate in the form of (x,y,z)
//Each node has a unique key in the form of (x,y,z)
//Nodes contain data which is generated by a generator function
//Nodes are generated on demand
//Node data is generated based on relations to other nodes

export class HexTree {
    private layers: HexLayer[] = [];
    public onNodeUpdate: (cell: HexNode) => void = (cell: HexNode) => {return cell};
    public onNodeCreate: (cell: HexNode) => void = (cell: HexNode) => {return cell};
    constructor() {
    }

    public addNode(x:number,y:number,z:number) {
        if (!this.layers[z]) {
            this.layers[z] = {
                nodes: {},
                population: 0
            }
        }
        if (!this.layers[z].nodes[`${x},${y},${z}`]) {
            this.layers[z].nodes[`${x},${y},${z}`] = new HexNode(x,y,z,this);
            this.onNodeCreate(this.layers[z].nodes[`${x},${y},${z}`]);
            this.layers[z].population++;
        }
    }

    public updateNode(x:number,y:number,z:number) {
        if (this.layers[z] && this.layers[z].nodes[`${x},${y},${z}`]) {
            let node = this.layers[z].nodes[`${x},${y},${z}`];
            node.getParents().forEach((parent) => {
                this.updateNode(parent.x,parent.y,parent.z);
            })
            this.onNodeUpdate(node);
        } 
    }
        

    public getHeight(): number {
        return this.layers.length;
    }
       

    public getNode(x: number, y: number, z: number): HexNode {
        if (this.layers[z] && this.layers[z].nodes[`${x},${y},${z}`]) {
            return this.layers[z].nodes[`${x},${y},${z}`];
        } else throw new Error(`Node ${x},${y},${z} does not exist`);
    }

    public getLayerPopulation(z: number): number {
        if (this.layers[z]) {
            return this.layers[z].population;
        } else throw new Error(`Layer ${z} does not exist`);
    }

    public getLayerNodes(z: number): HexNode[] {
        if (this.layers[z]) {
            return Object.values(this.layers[z].nodes);
        } else throw new Error(`Layer ${z} does not exist`);
    }

    public getParents(x: number, y: number, z: number): HexNode[] {
        let parents: HexNode[] = [];
        if (z < this.layers.length - 1) {
            parents.push(this.getNode(x,y,z+1));
        }
        return parents;
    }
}

export interface HexLayer {
    nodes: {[key: string]: HexNode};
    population: number;
}

export class HexNode {
    public x: number;
    public y: number;
    public z: number;
    public data: any;
    private tree: HexTree;
    constructor(x: number, y: number, z: number, tree: HexTree, data?: any) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.tree = tree;
        this.data = data;

        //Check for parent nodes
        if(this.isCentral()&&(this.x!==0||this.y!==0)) {
            this.z%2 ? this.tree.addNode(this.x/3,this.y,this.z+1): this.tree.addNode(this.x,this.y/3,this.z+1);
        }
        if (this.tree.getLayerPopulation(this.z) === 1) {
            this.tree.addNode(0,0,this.z+1);
        }
        let parents = this.getParents();
        if (!parents[0]) {
            let coordinates = this.getNeighborCoordinates();
            coordinates.forEach((coordinates) => {
                if ((this.z%2===0 ? coordinates.y%3===0 : coordinates.x%3===0)&& (Math.abs(coordinates.x) <= Math.abs(this.x) || Math.abs(coordinates.y) <= Math.abs(this.y))) {
                    this.z%2 ? this.tree.addNode(coordinates.x/3,coordinates.y,this.z+1): this.tree.addNode(coordinates.x,coordinates.y/3,this.z+1)
                }
            })
        }
    }

    private isCentral(): boolean {
        return(this.z%2===0 ? this.y%3===0 : this.x%3===0);
    }

    public getChildren(): HexNode[] {
        let children: HexNode[] = [];
        try {
            children.push(this.z%2? 
                this.tree.getNode(this.x*3,this.y,this.z-1)
                : this.tree.getNode(this.x,this.y*3,this.z-1)
            );
        } catch(e) {}
        if (children[0]) {
            children.push(...children[0].getNeighbors());
        }
        return children;
    }

    public getParents(): HexNode[] {
        let parents: HexNode[] = [];
        let neighborCoordinates = this.getNeighborCoordinates();
        neighborCoordinates.forEach((coordinates) => {
            if (this.z%2? coordinates.x%3===0 : coordinates.y%3===0) {
                try {
                    let node = (this.z%2?
                        this.tree.getNode(coordinates.x/3,coordinates.y,this.z+1)
                        : this.tree.getNode(coordinates.x,coordinates.y/3,this.z+1)    
                    )
                    if (node) {
                        parents.push(node);
                    }
                } catch(e) {}
            }
        })
        if(this.isCentral()&&(this.x!==0||this.y!==0)) {
            try {
                let node = this.z%2 ? this.tree.getNode(this.x/3,this.y,this.z+1): this.tree.getNode(this.x,this.y/3,this.z+1);
                if (node) {
                    parents.push(node);
                }
            } catch(e) {}
        }
        return parents;
    }

    private getNeighborCoordinates(): {x:number,y:number}[] {
        let coordinates: {x:number,y:number}[] = [];
        for (let x = this.x-1-this.z%2; x <= this.x+1+this.z%2; x++) {
            for (let y = this.y-1-(this.z+1)%2; y <= this.y+1+(this.z+1)%2; y++) {
                if ((x+y)%2===0 && !(x===this.x && y===this.y)) {
                    coordinates.push({x:x,y:y});
                }
            }
        }
        return coordinates;
    }


    public getNeighbors(): HexNode[] {
        let neighbors: HexNode[] = [];
        this.getNeighborCoordinates().forEach((coordinates) => {
            try {
                let node = this.tree.getNode(coordinates.x,coordinates.y,this.z);
                if (node) {
                    neighbors.push(node);
                }
            } catch(e) {}
        })
        return neighbors;
    }

    public addNeighborNodes(): void {
        this.getNeighborCoordinates().forEach((coordinates) => {
            this.tree.addNode(coordinates.x,coordinates.y,this.z);
        })
    }
}
